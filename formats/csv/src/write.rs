use std::io::Write;

use embroidery_lib::format::PatternWriter;
use embroidery_lib::prelude::*;
use embroidery_lib::utils::{build_stitch_list, StitchInfo};

pub struct CsvPatternWriter {}

impl Default for CsvPatternWriter {
    fn default() -> Self {
        CsvPatternWriter {}
    }
}

impl PatternWriter for CsvPatternWriter {
    fn write_pattern(&self, pattern: &Pattern, writer: &mut dyn Write) -> Result<(), WriteError> {
        write_header(writer)?;
        write_vars(pattern, writer)?;
        write_threads(pattern, writer)?;
        write_stitches(pattern, writer)?;
        Ok(())
    }
}

macro_rules! write_csv_var {
    ($writer: expr, $key: expr, $value: expr) => {
        writeln!($writer, "\">\",\"{}:\",\"{}\"", $key, $value)
    };
}

macro_rules! write_csv_comment {
    ($writer: expr, $value: expr) => {
        writeln!($writer, "\"#\",\"{}\"", $value)
    };
}
macro_rules! write_csv_stitch {
    ($writer: expr, $type: expr, $stitch: expr) => {
        writeln!($writer, "\"*\",\"{}\",\"{}\",\"{}\"", $type, $stitch.x, $stitch.y)
    };
}

fn write_header(writer: &mut dyn Write) -> Result<(), WriteError> {
    for line in HEADER.lines() {
        if line.is_empty() {
            writeln!(writer)?;
        } else {
            write_csv_comment!(writer, line)?;
        }
    }
    writeln!(writer)?;
    Ok(())
}
fn write_vars(pattern: &Pattern, writer: &mut dyn Write) -> Result<(), WriteError> {
    let (min_x, min_y, max_x, max_y) = pattern.get_bounds();
    let stitch_count = pattern.iter_stitches().count();
    let thread_count = pattern.color_groups.len();

    write_csv_comment!(writer, "[VAR_NAME]\",\"[VAR_VALUE]")?;
    write_csv_var!(writer, "STITCH_COUNT", stitch_count)?;
    write_csv_var!(writer, "THREAD_COUNT", thread_count)?;
    write_csv_var!(writer, "EXTENTS_LEFT", min_x)?;
    write_csv_var!(writer, "EXTENTS_TOP", min_y)?;
    write_csv_var!(writer, "EXTENTS_RIGHT", max_x)?;
    write_csv_var!(writer, "EXTENTS_BOTTOM", max_y)?;
    write_csv_var!(writer, "EXTENTS_WIDTH", max_x - min_x)?;
    write_csv_var!(writer, "EXTENTS_HEIGHT", max_y - min_y)?;
    writeln!(writer)?;
    for attr in pattern.attributes.iter() {
        match attr {
            PatternAttribute::Arbitrary(key, value) => {
                write_csv_var!(writer, key, value)?;
            },
            PatternAttribute::Title(value) => {
                write_csv_var!(writer, "Title", value)?;
            },
            PatternAttribute::Author(value) => {
                write_csv_var!(writer, "Author", value)?;
            },
            PatternAttribute::Copyright(value) => {
                write_csv_var!(writer, "Copyright", value)?;
            },
        };
    }
    writeln!(writer)?;
    Ok(())
}

fn write_threads(pattern: &Pattern, writer: &mut dyn Write) -> Result<(), WriteError> {
    write_csv_comment!(
        writer,
        "[THREAD_NUMBER]\",\"[RED]\",\"[GREEN]\",\"[BLUE]\",\"[DESCRIPTION]\",\"[CATALOG_NUMBER]"
    )?;

    for (i, cg) in pattern.color_groups.iter().enumerate() {
        match &cg.thread {
            Some(thread) => writeln!(
                writer,
                "\"$\",\"{}\",\"{}\",\"{}\",\"{}\",\"{}\",\"{}\"",
                i + 1,
                thread.color.red,
                thread.color.green,
                thread.color.blue,
                thread.name,
                thread.code
            )?,
            None => writeln!(writer, "\"$\",\"{}\",\"\",\"\",\"\",\"Unknown\",\"\"", i + 1)?,
        }
    }
    writeln!(writer)?;
    Ok(())
}
fn write_stitches(pattern: &Pattern, writer: &mut dyn Write) -> Result<(), WriteError> {
    write_csv_comment!(writer, "[STITCH_TYPE]\",\"[X]\",\"[Y]")?;

    for si in build_stitch_list(pattern) {
        match si {
            StitchInfo::Color(_, s) => {
                write_csv_stitch!(writer, "JUMP", s)?;
                write_csv_stitch!(writer, "COLOR", s)?;
            },
            StitchInfo::Cut(s) => write_csv_stitch!(writer, "TRIM", s)?,
            StitchInfo::End(s) => write_csv_stitch!(writer, "END", s)?,
            StitchInfo::Jump(s) => write_csv_stitch!(writer, "STITCH", s)?,
            StitchInfo::Stitch(s) => write_csv_stitch!(writer, "STITCH", s)?,
        }
    }
    writeln!(writer)?;
    Ok(())
}

const HEADER: &str = "
Embroidermodder 2 CSV Embroidery File
http://embroidermodder.github.io
Generated by Embroidery-Rust

General Notes:
This file can be read by Excel or LibreOffice as CSV (Comma Separated Value) or with a text editor.
Lines beginning with # are comments.
Lines beginning with > are variables: [VAR_NAME], [VAR_VALUE]
Lines beginning with $ are threads: [THREAD_NUMBER], [RED], [GREEN], [BLUE], [DESCRIPTION], [CATALOG_NUMBER]
Lines beginning with * are stitch entries: [STITCH_TYPE], [X], [Y]

Stitch Entry Notes:
STITCH instructs the machine to move to the position [X][Y] and then make a stitch.
JUMP instructs the machine to move to the position [X][Y] without making a stitch.
TRIM instructs the machine to cut the thread before moving to the position [X][Y] without making a stitch.
COLOR instructs the machine to stop temporarily so that the user can change to a different color thread before resuming.
END instructs the machine that the design is completed and there are no further instructions.
UNKNOWN encompasses instructions that may not be supported currently.
[X] and [Y] are absolute coordinates in millimeters (mm).
";
