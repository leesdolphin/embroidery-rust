use std::io::Read;

use byteorder::BigEndian;

use embroidery_lib::errors::add_context_fn;
use embroidery_lib::prelude::*;
use embroidery_lib::{read_exact_magic, read_int};

use crate::common::util::read_wide_string_field;

fn pair_window<'a, T>(iter: &'a [T]) -> Vec<(&'a T, Option<&'a T>)> {
    let mut next_item_iter = iter.iter().skip(1);
    let mut collect = Vec::with_capacity(iter.len());
    for item in iter {
        collect.push((item, next_item_iter.next()))
    }
    collect
}

pub fn read_font_pattern(reader: &mut dyn Read, character_offsets: &[(char, u32)]) -> Result<Vec<(char)>, ReadError> {
    if character_offsets.is_empty() {
        return Ok(vec![]);
    }
    let bytes_read: u64 = 0;

    for (i, &(&(chr, offset), next_char)) in pair_window(character_offsets).iter().enumerate() {
        let this_char_bytes: Option<u64> = next_char.map(|&(_, next)| (next - offset).into());
        let offset = offset.into();

        add_context_fn(
            || {
                if bytes_read > offset {
                    return Err(ReadError::invalid_format(format!(
                        "Offset was beyond the current offset. Currently at {}, expecting {}",
                        bytes_read, offset
                    )));
                }
                let constrained_reader = reader.take(this_char_bytes.unwrap_or(std::u64::MAX));

                Ok(())
            },
            || format!("Error ocurred whilst processing character {:?} at index {}.", chr, i),
        )?;
    }

    Ok(vec![])
}

pub fn read_char_pattern(reader: &mut dyn Read) -> Result<u8, ReadError> {
    read_exact_magic!(
        reader,
        [
            0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23,
            0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x64, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x78, 0x78, 0x50, 0x50, 0x01, 0x00,
        ]
    )?;

    let software_string = read_wide_string_field(reader, "software_string")?;
    let thread_count = read_int!(reader, u16, BigEndian);

    Ok(0)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pair_window() {
        assert_eq!(pair_window::<u8>(&[]), vec![]);
        assert_eq!(pair_window(&[1]), vec![(&1, None)]);
        assert_eq!(pair_window(&[1, 2]), vec![(&1, Some(&2)), (&2, None)]);
        assert_eq!(
            pair_window(&[1, 2, 3]),
            vec![(&1, Some(&2)), (&2, Some(&3)), (&3, None)]
        );
    }

    mod read_char_pattern {
        use super::*;

        #[test]
        fn test_send_vf3_space_character() {
            // Send.vf3  StartOffset(h): 000002CD, EndOffset(h): 00000354, Length(h): 00000088
            let data: [u8; 0x88] = [
                0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x23, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x64, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x78, 0x78, 0x50, 0x50, 0x01, 0x00, 0x00,
                0x30, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00, 0x63, 0x00, 0x65, 0x00, 0x64,
                0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00, 0x56, 0x00, 0x53, 0x00, 0x4D, 0x00, 0x20, 0x00,
                0x47, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x70, 0x00, 0x20, 0x00, 0x41, 0x00, 0x42, 0x00, 0x00,
            ];
            let reader = &mut &data[..];

            let pattern = read_char_pattern(reader).unwrap();
            assert_eq!(reader, &[]);
            assert_eq!(pattern, 0);
        }

        #[test]
        fn test_send_vf3_exclamation_character() {
            // Send.vf3  StartOffset(h): 00000355, EndOffset(h): 00000495, Length(h): 00000141
            let data: [u8; 0x141] = [
                0x00, 0x11, 0x00, 0x00, 0x00, 0x01, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x13, 0xEC, 0xFF, 0xFF, 0xF3, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0xFF, 0xFF, 0xEF, 0xFC, 0x00, 0x00, 0x10, 0x04, 0xFF, 0xFF, 0xCE, 0x32, 0x00, 0x00, 0x31, 0xCE, 0x00,
                0x00, 0x20, 0x08, 0x00, 0x00, 0x63, 0x9C, 0x00, 0x00, 0x64, 0x64, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x78, 0x78, 0x50, 0x50, 0x01, 0x00, 0x00,
                0x30, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00, 0x63, 0x00, 0x65, 0x00, 0x64,
                0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00, 0x56, 0x00, 0x53, 0x00, 0x4D, 0x00, 0x20, 0x00,
                0x47, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x70, 0x00, 0x20, 0x00, 0x41, 0x00, 0x42, 0x00, 0x01,
                0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0xB2, 0xFF, 0xFF, 0xEF, 0xFC, 0xFF, 0xFF, 0xD0, 0x26, 0x01, 0x00,
                0x0B, 0xC1, 0xD7, 0x00, 0x00, 0x00, 0x05, 0x28, 0x00, 0x04, 0x32, 0x35, 0x31, 0x38, 0x00, 0x11, 0x49,
                0x6E, 0x64, 0x69, 0x61, 0x6E, 0x20, 0x4F, 0x63, 0x65, 0x61, 0x6E, 0x20, 0x42, 0x6C, 0x75, 0x65, 0x00,
                0x16, 0x52, 0x6F, 0x62, 0x69, 0x73, 0x6F, 0x6E, 0x2D, 0x41, 0x6E, 0x74, 0x6F, 0x6E, 0x20, 0x52, 0x61,
                0x79, 0x6F, 0x6E, 0x20, 0x34, 0x30, 0x00, 0x00, 0x1C, 0x20, 0x00, 0x00, 0x0C, 0x80, 0x00, 0x01, 0x00,
                0x00, 0x00, 0x00, 0x5F, 0x0A, 0xF6, 0x00, 0x39, 0xC0, 0x03, 0x00, 0xFE, 0x00, 0x04, 0x00, 0xFC, 0x00,
                0xFD, 0xE7, 0x00, 0xFB, 0xFD, 0xE7, 0x00, 0xFC, 0xFD, 0xE7, 0xFF, 0xFC, 0xFD, 0xE7, 0x00, 0xFC, 0xFD,
                0xE7, 0x00, 0xFB, 0x01, 0xE7, 0x15, 0xF2, 0x11, 0x12, 0x01, 0x15, 0xFD, 0x19, 0xFF, 0x05, 0xFD, 0x19,
                0x00, 0x04, 0xFD, 0x19, 0x00, 0x04, 0xFD, 0x19, 0x00, 0x04, 0xFD, 0x19, 0xFD, 0x05, 0xFA, 0x00, 0x03,
                0x00, 0xFE, 0x00, 0x04, 0x00, 0x0D, 0x23, 0xFE, 0xFE, 0x01, 0x01, 0xFE, 0xFE, 0x08, 0x18, 0xEB, 0x0D,
                0xEF, 0xEE, 0x0D, 0xEB, 0x10, 0x01, 0x04, 0x04, 0xFE, 0xFE, 0x01, 0x01, 0xFE, 0xFE, 0x00,
            ];
            let reader = &mut &data[..];

            let pattern = read_char_pattern(reader).unwrap();
            assert_eq!(reader, &[]);
            assert_eq!(pattern, 0);
        }
    }
}
