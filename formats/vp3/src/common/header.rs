use byteorder::BigEndian;

use embroidery_lib::prelude::*;
use embroidery_lib::{read_exact_magic, read_int};

use std::io::Read;

use super::util::read_wide_string_field;

use self::vf3::{read_font_header, Vf3Header};
use self::vp3::{read_pattern_header, Vp3Header};

mod vf3;
mod vp3;

#[derive(Debug, PartialEq, Eq)]
pub enum FileType {
    Pattern,
    Font,
}

#[derive(Debug, PartialEq)]
pub enum Header {
    Pattern(Vp3Header),
    Font(Vf3Header),
}

#[derive(Debug, PartialEq)]
pub struct CommonHeader {
    pub software_vendor_string: String,
    pub file_type: FileType,
    pub bytes_remaining: u32,
}

pub fn read_header<'a>(
    ub_reader: &'a mut dyn Read,
    expected_format: Option<FileType>,
) -> Result<(CommonHeader, Header, std::io::Take<&'a mut dyn Read>), ReadError> {
    let (common_header, mut reader) = read_common_header(ub_reader)?;
    if let Some(format) = expected_format {
        if common_header.file_type != format {
            return Err(ReadError::invalid_format(format!(
                "The file was detected as {:?}, but we were trying to read {:?}",
                common_header.file_type, format
            )));
        }
    }

    match common_header.file_type {
        FileType::Font => Ok((common_header, Header::Font(read_font_header(&mut reader)?), reader)),
        FileType::Pattern => Ok((
            common_header,
            Header::Pattern(read_pattern_header(&mut reader)?),
            reader,
        )),
    }
}

pub fn read_common_header<'a>(
    ub_reader: &'a mut dyn Read,
) -> Result<(CommonHeader, std::io::Take<&'a mut dyn Read>), ReadError> {
    read_exact_magic!(ub_reader, b"%vsm%\0")?;

    let software_vendor_string = read_wide_string_field(ub_reader, "software_vendor_string")?;

    let mut file_type_magics = [0_u8; 3];
    ub_reader.read_exact(&mut file_type_magics)?;
    let file_type = match file_type_magics {
        [0x00, 0x02, 0x00] => FileType::Pattern,
        [0x00, 0x1D, 0x00] => FileType::Font,
        other => {
            return Err(ReadError::invalid_format(format!(
                "Incorrect file type magic bytes {:?}",
                other
            )))
        },
    };
    let bytes_remaining = read_int!(ub_reader, u32, BigEndian)?;
    let reader = ub_reader.take(bytes_remaining.into());

    Ok((
        CommonHeader {
            software_vendor_string,
            file_type,
            bytes_remaining,
        },
        reader,
    ))
}

#[cfg(test)]
mod tests {
    use super::*;

    use super::vf3::Vf3Header;
    use super::vp3::{Vp3Header, Vp3Hoop};

    #[test]
    fn test_read_header_send_vf3() {
        // Send.vf3 StartOffset(h): 00000000, EndOffset(h): 000000FF, Length(h): 00000100
        let data: [u8; 256] = [
            0x25, 0x76, 0x73, 0x6D, 0x25, 0x00, 0x00, 0x30, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75,
            0x00, 0x63, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00, 0x56, 0x00, 0x53,
            0x00, 0x4D, 0x00, 0x20, 0x00, 0x47, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x70, 0x00, 0x20, 0x00, 0x41,
            0x00, 0x42, 0x00, 0x1D, 0x00, 0x00, 0x00, 0x94, 0xFA, 0x00, 0x1E, 0x00, 0x54, 0x00, 0x69, 0x00, 0x6D, 0x00,
            0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x4E, 0x00, 0x65, 0x00, 0x77, 0x00, 0x20, 0x00, 0x52, 0x00, 0x6F, 0x00,
            0x6D, 0x00, 0x61, 0x00, 0x6E, 0x08, 0x57, 0x65, 0x73, 0x74, 0x65, 0x72, 0x6E, 0x31, 0x00, 0x19, 0x00, 0x33,
            0x42, 0x3E, 0x18, 0x02, 0xB3, 0x93, 0x48, 0x8F, 0x52, 0x89, 0x51, 0xE3, 0x78, 0xBA, 0x9A, 0x00, 0x22, 0x00,
            0x23, 0x00, 0x62, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x88, 0x00, 0x26, 0x00,
            0x00, 0x01, 0xC9, 0x00, 0x2C, 0x00, 0x00, 0x03, 0x80, 0x00, 0x2D, 0x00, 0x00, 0x04, 0x93, 0x00, 0x2E, 0x00,
            0x00, 0x05, 0xA2, 0x00, 0x30, 0x00, 0x00, 0x06, 0xA1, 0x00, 0x31, 0x00, 0x00, 0x08, 0x04, 0x00, 0x32, 0x00,
            0x00, 0x09, 0x53, 0x00, 0x33, 0x00, 0x00, 0x0A, 0xAE, 0x00, 0x34, 0x00, 0x00, 0x0B, 0xFB, 0x00, 0x35, 0x00,
            0x00, 0x0D, 0x74, 0x00, 0x36, 0x00, 0x00, 0x0E, 0xC3, 0x00, 0x37, 0x00, 0x00, 0x10, 0x2E, 0x00, 0x38, 0x00,
            0x00, 0x11, 0x93, 0x00, 0x39, 0x00, 0x00, 0x13, 0x16, 0x00, 0x3C, 0x00, 0x00, 0x14, 0x7F, 0x00, 0x3F, 0x00,
            0x00, 0x15, 0x07, 0x00, 0x40, 0x00, 0x00, 0x16, 0x50, 0x00, 0x41, 0x00, 0x00, 0x18, 0x57, 0x00, 0x42, 0x00,
            0x00, 0x19, 0xE6, 0x00,
        ];
        let (common_header, header, _) = read_header(&mut &data[..], None).unwrap();
        assert_eq!(
            common_header,
            CommonHeader {
                software_vendor_string: "Produced by     Software Ltd".to_string(),
                file_type: FileType::Pattern,
                bytes_remaining: 55_361, /* 0x00_00_D8_41 */
            }
        );
        assert_eq!(
            header,
            Header::Font(Vf3Header {
                font_name: "".to_string(),
                character_encoding: "".to_string(),
                character_offsets: vec![],
            })
        );
    }

    #[test]
    fn test_read_file_t160_vp3() {
        // T160.vp3 StartOffset(h): 00000000, EndOffset(h): 000000FF, Length(h): 00000100

        let data: [u8; 256] = [
            0x25, 0x76, 0x73, 0x6D, 0x25, 0x00, 0x00, 0x38, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75,
            0x00, 0x63, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
            0x00, 0x20, 0x00, 0x20, 0x00, 0x53, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x74, 0x00, 0x77, 0x00, 0x61, 0x00, 0x72,
            0x00, 0x65, 0x00, 0x20, 0x00, 0x4C, 0x00, 0x74, 0x00, 0x64, 0x00, 0x02, 0x00, 0x00, 0x00, 0xD8, 0x41, 0x00,
            0x00, 0x00, 0x00, 0xF2, 0x30, 0x00, 0x01, 0x4F, 0xF0, 0xFF, 0xFF, 0x0D, 0xD0, 0xFF, 0xFE, 0xB0, 0x10, 0x00,
            0x00, 0x69, 0xB5, 0x00, 0x08, 0x0C, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xD8, 0x1F, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x0D, 0xD0, 0x00, 0x00, 0xF2, 0x30, 0xFF, 0xFE,
            0xB0, 0x10, 0x00, 0x01, 0x4F, 0xF0, 0x00, 0x01, 0xE4, 0x60, 0x00, 0x02, 0x9F, 0xE0, 0x00, 0x00, 0x64, 0x64,
            0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x78, 0x78,
            0x50, 0x50, 0x01, 0x00, 0x00, 0x38, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00, 0x63,
            0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
            0x00, 0x20, 0x00, 0x53, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x74, 0x00, 0x77, 0x00, 0x61, 0x00, 0x72, 0x00, 0x65,
            0x00, 0x20, 0x00, 0x4C, 0x00, 0x74, 0x00, 0x64, 0x00, 0x08, 0x00, 0x05, 0x00, 0x00, 0x00, 0x1C, 0xBB, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xDE, 0xE6, 0xE8, 0x00, 0x00, 0x00, 0x05, 0x28, 0x00,
            0x04, 0x31, 0x30, 0x30,
        ];

        let (common_header, header, _) = read_header(&mut &data[..], None).unwrap();
        assert_eq!(
            common_header,
            CommonHeader {
                software_vendor_string: "Produced by     Software Ltd".to_string(),
                file_type: FileType::Pattern,
                bytes_remaining: 55_361, /* 0x00_00_D8_41 */
            }
        );
        assert_eq!(
            header,
            Header::Pattern(Vp3Header {
                file_comment_string: "".to_string(),
                another_software_vendor_string: "Produced by     Software Ltd".to_string(),
                number_of_threads: 8,
                hoop: Vp3Hoop {
                    right: -62_000,
                    left: 62_000,
                    bottom: -86_000,
                    top: 86_000,
                    unknown_a: 27061,
                    unknown_b: 8,
                    bytes_remaining: 55327,
                    x_offset: 0,
                    y_offset: 0,

                    right2: -62_000,
                    left2: 62_000,
                    bottom2: -86_000,
                    top2: 86_000,
                    width: 124_000,
                    height: 172_000,
                }
            })
        );
    }
}
