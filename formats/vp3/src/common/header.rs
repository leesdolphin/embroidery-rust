use byteorder::BigEndian;

use embroidery_lib::prelude::*;
use embroidery_lib::{read_exact_magic, read_int};

use std::io::Read;

use super::util::read_wide_string_field;

use self::vf3::{read_font_header, Vf3Header};
use self::vp3::{read_pattern_header, Vp3Header};

mod vf3;
mod vp3;

#[derive(Debug, PartialEq, Eq)]
pub enum FileType {
    Pattern,
    Font,
}

#[derive(Debug, PartialEq)]
pub enum Header {
    Pattern(Vp3Header),
    Font(Vf3Header),
}

#[derive(Debug, PartialEq)]
pub struct CommonHeader {
    pub software_vendor_string: String,
    pub file_type: FileType,
    pub bytes_remaining: u32,
}

pub fn read_header<'a>(
    ub_reader: &'a mut dyn Read,
    expected_format: Option<FileType>,
) -> Result<(CommonHeader, Header, std::io::Take<&'a mut dyn Read>), ReadError> {
    let (common_header, mut reader) = read_common_header(ub_reader)?;
    if let Some(format) = expected_format {
        if common_header.file_type != format {
            return Err(ReadError::invalid_format(format!(
                "The file was detected as {:?}, but we were trying to read {:?}",
                common_header.file_type, format
            )));
        }
    }

    match common_header.file_type {
        FileType::Font => Ok((common_header, Header::Font(read_font_header(&mut reader)?), reader)),
        FileType::Pattern => Ok((
            common_header,
            Header::Pattern(read_pattern_header(&mut reader)?),
            reader,
        )),
    }
}

pub fn read_common_header<'a>(
    ub_reader: &'a mut dyn Read,
) -> Result<(CommonHeader, std::io::Take<&'a mut dyn Read>), ReadError> {
    read_exact_magic!(ub_reader, b"%vsm%\0")?;

    let software_vendor_string = read_wide_string_field(ub_reader, "software_vendor_string")?;

    let mut file_type_magics = [0_u8; 3];
    ub_reader.read_exact(&mut file_type_magics)?;
    let file_type = match file_type_magics {
        [0x00, 0x02, 0x00] => FileType::Pattern,
        [0x00, 0x1D, 0x00] => FileType::Font,
        other => {
            return Err(ReadError::invalid_format(format!(
                "Incorrect file type magic bytes {:?}",
                other
            )))
        },
    };
    let bytes_remaining = read_int!(ub_reader, u32, BigEndian)?;
    let reader = ub_reader.take(bytes_remaining.into());

    Ok((
        CommonHeader {
            software_vendor_string,
            file_type,
            bytes_remaining,
        },
        reader,
    ))
}

#[cfg(test)]
mod tests {
    use super::*;

    use super::vf3::Vf3Header;
    use super::vp3::{Vp3Header, Vp3Hoop};

    #[test]
    fn test_read_header_send_vf3() {
        // Send.vf3  StartOffset(h): 00000000, EndOffset(h): 00000325, Length(h): 00000326
        let data: [u8; 0x326] = [
            0x25, 0x76, 0x73, 0x6D, 0x25, 0x00, 0x00, 0x30, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75,
            0x00, 0x63, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00, 0x56, 0x00, 0x53,
            0x00, 0x4D, 0x00, 0x20, 0x00, 0x47, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x75, 0x00, 0x70, 0x00, 0x20, 0x00, 0x41,
            0x00, 0x42, 0x00, 0x1D, 0x00, 0x00, 0x00, 0x94, 0xFA, 0x00, 0x1E, 0x00, 0x54, 0x00, 0x69, 0x00, 0x6D, 0x00,
            0x65, 0x00, 0x73, 0x00, 0x20, 0x00, 0x4E, 0x00, 0x65, 0x00, 0x77, 0x00, 0x20, 0x00, 0x52, 0x00, 0x6F, 0x00,
            0x6D, 0x00, 0x61, 0x00, 0x6E, 0x08, 0x57, 0x65, 0x73, 0x74, 0x65, 0x72, 0x6E, 0x31, 0x00, 0x19, 0x00, 0x33,
            0x42, 0x3E, 0x18, 0x02, 0xB3, 0x93, 0x48, 0x8F, 0x52, 0x89, 0x51, 0xE3, 0x78, 0xBA, 0x9A, 0x00, 0x22, 0x00,
            0x23, 0x00, 0x62, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x88, 0x00, 0x26, 0x00,
            0x00, 0x01, 0xC9, 0x00, 0x2C, 0x00, 0x00, 0x03, 0x80, 0x00, 0x2D, 0x00, 0x00, 0x04, 0x93, 0x00, 0x2E, 0x00,
            0x00, 0x05, 0xA2, 0x00, 0x30, 0x00, 0x00, 0x06, 0xA1, 0x00, 0x31, 0x00, 0x00, 0x08, 0x04, 0x00, 0x32, 0x00,
            0x00, 0x09, 0x53, 0x00, 0x33, 0x00, 0x00, 0x0A, 0xAE, 0x00, 0x34, 0x00, 0x00, 0x0B, 0xFB, 0x00, 0x35, 0x00,
            0x00, 0x0D, 0x74, 0x00, 0x36, 0x00, 0x00, 0x0E, 0xC3, 0x00, 0x37, 0x00, 0x00, 0x10, 0x2E, 0x00, 0x38, 0x00,
            0x00, 0x11, 0x93, 0x00, 0x39, 0x00, 0x00, 0x13, 0x16, 0x00, 0x3C, 0x00, 0x00, 0x14, 0x7F, 0x00, 0x3F, 0x00,
            0x00, 0x15, 0x07, 0x00, 0x40, 0x00, 0x00, 0x16, 0x50, 0x00, 0x41, 0x00, 0x00, 0x18, 0x57, 0x00, 0x42, 0x00,
            0x00, 0x19, 0xE6, 0x00, 0x43, 0x00, 0x00, 0x1B, 0xAD, 0x00, 0x44, 0x00, 0x00, 0x1D, 0x12, 0x00, 0x45, 0x00,
            0x00, 0x1E, 0xB3, 0x00, 0x46, 0x00, 0x00, 0x20, 0x78, 0x00, 0x47, 0x00, 0x00, 0x22, 0x1B, 0x00, 0x48, 0x00,
            0x00, 0x23, 0x9A, 0x00, 0x49, 0x00, 0x00, 0x25, 0x83, 0x00, 0x4A, 0x00, 0x00, 0x26, 0xEE, 0x00, 0x4B, 0x00,
            0x00, 0x28, 0x49, 0x00, 0x4C, 0x00, 0x00, 0x2A, 0x0E, 0x00, 0x4D, 0x00, 0x00, 0x2B, 0x89, 0x00, 0x4E, 0x00,
            0x00, 0x2D, 0xAC, 0x00, 0x4F, 0x00, 0x00, 0x2F, 0x6B, 0x00, 0x50, 0x00, 0x00, 0x30, 0xE0, 0x00, 0x51, 0x00,
            0x00, 0x32, 0x6D, 0x00, 0x52, 0x00, 0x00, 0x33, 0xF8, 0x00, 0x53, 0x00, 0x00, 0x35, 0xA3, 0x00, 0x54, 0x00,
            0x00, 0x37, 0x12, 0x00, 0x55, 0x00, 0x00, 0x38, 0xA3, 0x00, 0x56, 0x00, 0x00, 0x3A, 0x2E, 0x00, 0x57, 0x00,
            0x00, 0x3B, 0xA7, 0x00, 0x58, 0x00, 0x00, 0x3D, 0x96, 0x00, 0x59, 0x00, 0x00, 0x3F, 0x3B, 0x00, 0x5A, 0x00,
            0x00, 0x40, 0xB8, 0x00, 0x61, 0x00, 0x00, 0x42, 0x45, 0x00, 0x62, 0x00, 0x00, 0x43, 0xAA, 0x00, 0x63, 0x00,
            0x00, 0x45, 0x25, 0x00, 0x64, 0x00, 0x00, 0x46, 0x5E, 0x00, 0x65, 0x00, 0x00, 0x47, 0xE5, 0x00, 0x66, 0x00,
            0x00, 0x49, 0x42, 0x00, 0x67, 0x00, 0x00, 0x4A, 0xA5, 0x00, 0x68, 0x00, 0x00, 0x4C, 0x42, 0x00, 0x69, 0x00,
            0x00, 0x4D, 0xCB, 0x00, 0x6A, 0x00, 0x00, 0x4F, 0x22, 0x00, 0x6B, 0x00, 0x00, 0x50, 0x87, 0x00, 0x6C, 0x00,
            0x00, 0x52, 0x14, 0x00, 0x6D, 0x00, 0x00, 0x53, 0x61, 0x00, 0x6E, 0x00, 0x00, 0x55, 0x12, 0x00, 0x6F, 0x00,
            0x00, 0x56, 0x81, 0x00, 0x70, 0x00, 0x00, 0x57, 0xD0, 0x00, 0x71, 0x00, 0x00, 0x59, 0x59, 0x00, 0x72, 0x00,
            0x00, 0x5A, 0xE4, 0x00, 0x73, 0x00, 0x00, 0x5C, 0x25, 0x00, 0x74, 0x00, 0x00, 0x5D, 0x70, 0x00, 0x75, 0x00,
            0x00, 0x5E, 0xBB, 0x00, 0x76, 0x00, 0x00, 0x60, 0x1C, 0x00, 0x77, 0x00, 0x00, 0x61, 0x6B, 0x00, 0x78, 0x00,
            0x00, 0x63, 0x04, 0x00, 0x79, 0x00, 0x00, 0x64, 0x6F, 0x00, 0x7A, 0x00, 0x00, 0x65, 0xD8, 0x00, 0xC4, 0x00,
            0x00, 0x67, 0x3B, 0x00, 0xC5, 0x00, 0x00, 0x69, 0x04, 0x00, 0xC6, 0x00, 0x00, 0x6A, 0xD9, 0x00, 0xD1, 0x00,
            0x00, 0x6C, 0xE6, 0x00, 0xD6, 0x00, 0x00, 0x6E, 0xDB, 0x00, 0xD8, 0x00, 0x00, 0x70, 0x8A, 0x00, 0xDC, 0x00,
            0x00, 0x72, 0x3F, 0x00, 0xDF, 0x00, 0x00, 0x74, 0x04, 0x00, 0xE0, 0x00, 0x00, 0x75, 0x89, 0x00, 0xE1, 0x00,
            0x00, 0x77, 0x16, 0x00, 0xE4, 0x00, 0x00, 0x78, 0xA3, 0x00, 0xE5, 0x00, 0x00, 0x7A, 0x42, 0x00, 0xE6, 0x00,
            0x00, 0x7B, 0xEB, 0x00, 0xE7, 0x00, 0x00, 0x7D, 0x90, 0x00, 0xE8, 0x00, 0x00, 0x7F, 0x09, 0x00, 0xE9, 0x00,
            0x00, 0x80, 0x88, 0x00, 0xEA, 0x00, 0x00, 0x82, 0x07, 0x00, 0xEB, 0x00, 0x00, 0x83, 0x94, 0x00, 0xED, 0x00,
            0x00, 0x85, 0x25, 0x00, 0xF1, 0x00, 0x00, 0x86, 0x80, 0x00, 0xF3, 0x00, 0x00, 0x88, 0x25, 0x00, 0xF6, 0x00,
            0x00, 0x89, 0x9C, 0x00, 0xF8, 0x00, 0x00, 0x8B, 0x25, 0x00, 0xF9, 0x00, 0x00, 0x8C, 0xA8, 0x00, 0xFA, 0x00,
            0x00, 0x8E, 0x31, 0x00, 0xFC, 0x00, 0x00, 0x8F, 0xBA, 0x20, 0x19, 0x00, 0x00, 0x91, 0x55, 0x00, 0x11, 0x00,
            0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x8C, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x64, 0x64, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x10, 0x00, 0x78, 0x78, 0x50, 0x50, 0x01, 0x00, 0x00, 0x30, 0x00, 0x50, 0x00,
        ];
        let (common_header, header, _) = read_header(&mut &data[..], None).unwrap();
        assert_eq!(
            common_header,
            CommonHeader {
                software_vendor_string: "Produced by VSM Group AB".to_string(),
                file_type: FileType::Font,
                bytes_remaining: 38138, /* 0x00_00_94_FA */
            }
        );
        assert_eq!(
            header,
            Header::Font(Vf3Header {
                font_name: "Times New Roman".to_string(),
                character_list: "Western1".to_string(),
                font_size_mm: 25,
                font_italic: false,
                font_bold: false,
                font_bounding_width: 34,
                font_bounding_height: 35,
                character_offsets: vec![
                    (' ', 0),
                    ('!', 136),
                    ('&', 457),
                    (',', 896),
                    ('-', 1171),
                    ('.', 1442),
                    ('0', 1697),
                    ('1', 2052),
                    ('2', 2387),
                    ('3', 2734),
                    ('4', 3067),
                    ('5', 3444),
                    ('6', 3779),
                    ('7', 4142),
                    ('8', 4499),
                    ('9', 4886),
                    ('<', 5247),
                    ('?', 5383),
                    ('@', 5712),
                    ('A', 6231),
                    ('B', 6630),
                    ('C', 7085),
                    ('D', 7442),
                    ('E', 7859),
                    ('F', 8312),
                    ('G', 8731),
                    ('H', 9114),
                    ('I', 9603),
                    ('J', 9966),
                    ('K', 10313),
                    ('L', 10766),
                    ('M', 11145),
                    ('N', 11692),
                    ('O', 12139),
                    ('P', 12512),
                    ('Q', 12909),
                    ('R', 13304),
                    ('S', 13731),
                    ('T', 14098),
                    ('U', 14499),
                    ('V', 14894),
                    ('W', 15271),
                    ('X', 15766),
                    ('Y', 16187),
                    ('Z', 16568),
                    ('a', 16965),
                    ('b', 17322),
                    ('c', 17701),
                    ('d', 18014),
                    ('e', 18405),
                    ('f', 18754),
                    ('g', 19109),
                    ('h', 19522),
                    ('i', 19915),
                    ('j', 20258),
                    ('k', 20615),
                    ('l', 21012),
                    ('m', 21345),
                    ('n', 21778),
                    ('o', 22145),
                    ('p', 22480),
                    ('q', 22873),
                    ('r', 23268),
                    ('s', 23589),
                    ('t', 23920),
                    ('u', 24251),
                    ('v', 24604),
                    ('w', 24939),
                    ('x', 25348),
                    ('y', 25711),
                    ('z', 26072),
                    ('Ä', 26427),
                    ('Å', 26884),
                    ('Æ', 27353),
                    ('Ñ', 27878),
                    ('Ö', 28379),
                    ('Ø', 28810),
                    ('Ü', 29247),
                    ('ß', 29700),
                    ('à', 30089),
                    ('á', 30486),
                    ('ä', 30883),
                    ('å', 31298),
                    ('æ', 31723),
                    ('ç', 32144),
                    ('è', 32521),
                    ('é', 32904),
                    ('ê', 33287),
                    ('ë', 33684),
                    ('í', 34085),
                    ('ñ', 34432),
                    ('ó', 34853),
                    ('ö', 35228),
                    ('ø', 35621),
                    ('ù', 36008),
                    ('ú', 36401),
                    ('ü', 36794),
                    ('’', 37205)
                ]
            })
        );
    }

    #[test]
    fn test_read_file_t160_vp3() {
        // T160.vp3 StartOffset(h): 00000000, EndOffset(h): 000000FF, Length(h): 00000100

        let data: [u8; 256] = [
            0x25, 0x76, 0x73, 0x6D, 0x25, 0x00, 0x00, 0x38, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75,
            0x00, 0x63, 0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
            0x00, 0x20, 0x00, 0x20, 0x00, 0x53, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x74, 0x00, 0x77, 0x00, 0x61, 0x00, 0x72,
            0x00, 0x65, 0x00, 0x20, 0x00, 0x4C, 0x00, 0x74, 0x00, 0x64, 0x00, 0x02, 0x00, 0x00, 0x00, 0xD8, 0x41, 0x00,
            0x00, 0x00, 0x00, 0xF2, 0x30, 0x00, 0x01, 0x4F, 0xF0, 0xFF, 0xFF, 0x0D, 0xD0, 0xFF, 0xFE, 0xB0, 0x10, 0x00,
            0x00, 0x69, 0xB5, 0x00, 0x08, 0x0C, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xD8, 0x1F, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x0D, 0xD0, 0x00, 0x00, 0xF2, 0x30, 0xFF, 0xFE,
            0xB0, 0x10, 0x00, 0x01, 0x4F, 0xF0, 0x00, 0x01, 0xE4, 0x60, 0x00, 0x02, 0x9F, 0xE0, 0x00, 0x00, 0x64, 0x64,
            0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x78, 0x78,
            0x50, 0x50, 0x01, 0x00, 0x00, 0x38, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x64, 0x00, 0x75, 0x00, 0x63,
            0x00, 0x65, 0x00, 0x64, 0x00, 0x20, 0x00, 0x62, 0x00, 0x79, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20,
            0x00, 0x20, 0x00, 0x53, 0x00, 0x6F, 0x00, 0x66, 0x00, 0x74, 0x00, 0x77, 0x00, 0x61, 0x00, 0x72, 0x00, 0x65,
            0x00, 0x20, 0x00, 0x4C, 0x00, 0x74, 0x00, 0x64, 0x00, 0x08, 0x00, 0x05, 0x00, 0x00, 0x00, 0x1C, 0xBB, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0xDE, 0xE6, 0xE8, 0x00, 0x00, 0x00, 0x05, 0x28, 0x00,
            0x04, 0x31, 0x30, 0x30,
        ];

        let (common_header, header, _) = read_header(&mut &data[..], None).unwrap();
        assert_eq!(
            common_header,
            CommonHeader {
                software_vendor_string: "Produced by     Software Ltd".to_string(),
                file_type: FileType::Pattern,
                bytes_remaining: 55_361, /* 0x00_00_D8_41 */
            }
        );
        assert_eq!(
            header,
            Header::Pattern(Vp3Header {
                file_comment_string: "".to_string(),
                another_software_vendor_string: "Produced by     Software Ltd".to_string(),
                number_of_threads: 8,
                hoop: Vp3Hoop {
                    right: -62_000,
                    left: 62_000,
                    bottom: -86_000,
                    top: 86_000,
                    unknown_a: 27061,
                    unknown_b: 8,
                    bytes_remaining: 55327,
                    x_offset: 0,
                    y_offset: 0,

                    right2: -62_000,
                    left2: 62_000,
                    bottom2: -86_000,
                    top2: 86_000,
                    width: 124_000,
                    height: 172_000,
                }
            })
        );
    }
}
